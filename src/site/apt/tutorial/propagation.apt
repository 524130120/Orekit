~~ Copyright 2002-2012 CS Syst√®mes d'Information
~~ Licensed under the Apache License, Version 2.0 (the "License");
~~ you may not use this file except in compliance with the License.
~~ You may obtain a copy of the License at
~~
~~   http://www.apache.org/licenses/LICENSE-2.0
~~
~~ Unless required by applicable law or agreed to in writing, software
~~ distributed under the License is distributed on an "AS IS" BASIS,
~~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
~~ See the License for the specific language governing permissions and
~~ limitations under the License.

Propagation

  The next 4 tutorials detail some elementary usages of the propagation package
  described in the {{{../architecture/propagation.html}propagation section}} of
  the library architecture documentation.

* Propagation modes

  Three different operational modes are available for all propagators.
  They are exclusive from each over.

** Slave mode

  It is the default mode, it doesn't need to be explicitly set, but it can be to recover from any other mode.
  
  This tutorial simply shows how to propagate from an initial state to a target date.

  In this case, the calling application coordinates all the tasks, the propagator just propagates.
  
  Let's define the EME2000 inertial frame as reference frame:
  
+---------------------
Frame inertialFrame = FramesFactory.getEME2000();
+---------------------
  
  Let's set up an initial state as:

  ** a date in some time scale
    
  ** a central attraction coefficient
    
  ** an orbit defined by its keplerian parameters.
    
  []

+---------------------
TimeScale utc = TimeScalesFactory.getUTC();
AbsoluteDate initialDate = new AbsoluteDate(2004, 01, 01, 23, 30, 00.000, utc);

double mu =  3.986004415e+14;

double a = 24396159;                 // semi major axis in meters
double e = 0.72831215;               // eccentricity
double i = Math.toRadians(7);        // inclination
double omega = Math.toRadians(180);  // perigee argument
double raan = Math.toRadians(261);   // right ascension of ascending node
double lM = 0;                       // mean anomaly
+---------------------

  The initial orbit is defined as a <KeplerianOrbit>.\
  More precisions on the orbit representation can be found
  in the {{{../architecture/orbits.html}orbits section}}
  of the library architecture documentation.

+---------------------
Orbit initialOrbit = new KeplerianOrbit(a, e, i, omega, raan, lM, PositionAngle.MEAN,
                                        inertialFrame, initialDate, mu);
+---------------------

  We choose to use a very simple <KeplerianPropagator> to compute basic keplerian motion.\
  It could be any of all the available propagators.

+---------------------
KeplerianPropagator kepler = new KeplerianPropagator(initialOrbit);
+---------------------

   Let's set the propagator to slave mode for the purpose of this tutorial,
   but keep in mind that it can be omitted here as it is the default mode.

+---------------------
kepler.setSlaveMode();
+---------------------

  Finally, the propagation features, duration and step size, are defined and
  a propagation loop is performed in order to print the results at each step:

+---------------------
double duration = 600.;
AbsoluteDate finalDate =  new AbsoluteDate(initialDate, duration, utc);
double stepT = 60.;
int cpt = 1;
AbsoluteDate extrapDate = initialDate;
while (extrapDate.compareTo(finalDate) <= 0)  {
    SpacecraftState currentState = kepler.propagate(extrapDate);
    System.out.println("step " + cpt++);
    System.out.println(" time : " + currentState.getDate());
    System.out.println(" " + currentState.getOrbit());
    extrapDate = new AbsoluteDate(extrapDate, stepT, utc);
}
+---------------------

  The printed results are shown below (lines have been wrapped for better
  presentation)

+---------------------
step 1
 time : 2004-01-01T23:30:00.000
 equinoctial parameters: {a: 2.4396159E7;
                          ex: 0.11393312156755062; ey: 0.719345418868777;
                          hx: -0.009567941763699867; hy: -0.06040960680288257;
                          lv: 441.0;}
step 2
 time : 2004-01-01T23:31:00.000
 equinoctial parameters: {a: 2.4396159E7;
                          ex: 0.11393312156755062; ey: 0.719345418868777;
                          hx: -0.009567941763699867; hy: -0.06040960680288257;
                          lv: 446.2813836335737;}
step 3
 time : 2004-01-01T23:32:00.000
 equinoctial parameters: {a: 2.4396159E7;
                          ex: 0.11393312156755062; ey: 0.719345418868777;
                          hx: -0.009567941763699867; hy: -0.06040960680288257;
                          lv: 451.5252613094112;}
step 4
 time : 2004-01-01T23:33:00.000
 equinoctial parameters: {a: 2.4396159E7;
                          ex: 0.11393312156755062; ey: 0.719345418868777;
                          hx: -0.009567941763699867; hy: -0.06040960680288257;
                          lv: 456.6958768398235;}
step 5
 time : 2004-01-01T23:34:00.000
 equinoctial parameters: {a: 2.4396159E7;
                          ex: 0.11393312156755062; ey: 0.719345418868777;
                          hx: -0.009567941763699867; hy: -0.06040960680288257;
                          lv: 461.7607703551739;}
step 6
 time : 2004-01-01T23:35:00.000
 equinoctial parameters: {a: 2.4396159E7;
                          ex: 0.11393312156755062; ey: 0.719345418868777;
                          hx: -0.009567941763699867; hy: -0.06040960680288257;
                          lv: 466.6919614270639;}
step 7
 time : 2004-01-01T23:36:00.000
 equinoctial parameters: {a: 2.4396159E7;
                          ex: 0.11393312156755062; ey: 0.719345418868777;
                          hx: -0.009567941763699867; hy: -0.06040960680288257;
                          lv: 471.4666804605399;}
step 8
 time : 2004-01-01T23:37:00.000
 equinoctial parameters: {a: 2.4396159E7;
                          ex: 0.11393312156755062; ey: 0.719345418868777;
                          hx: -0.009567941763699867; hy: -0.06040960680288257;
                          lv: 476.0676390794578;}
step 9
 time : 2004-01-01T23:38:00.000
 equinoctial parameters: {a: 2.4396159E7;
                          ex: 0.11393312156755062; ey: 0.719345418868777;
                          hx: -0.009567941763699867; hy: -0.06040960680288257;
                          lv: 480.4828961502498;}
step 10
 time : 2004-01-01T23:39:00.000
 equinoctial parameters: {a: 2.4396159E7;
                          ex: 0.11393312156755062; ey: 0.719345418868777;
                          hx: -0.009567941763699867; hy: -0.06040960680288257;
                          lv: 484.70541689946305;}
step 11
 time : 2004-01-01T23:40:00.000
 equinoctial parameters: {a: 2.4396159E7;
                          ex: 0.11393312156755062; ey: 0.719345418868777;
                          hx: -0.009567941763699867; hy: -0.06040960680288257;
                          lv: 488.7324362945905;}
+---------------------

*** Source code

  The complete code for this example can be found in the source tree of the library,
  in file <<<src/tutorials/fr/cs/examples/propagation/SlaveMode.java>>>.

** Master mode

  In this mode, the propagator, as a master, calls some callback methods,
  provided by the application, throughout its internal integration loop.

  Like in the slave mode tutorial above, let's define some initial state with:

  ** an inertial frame

  ** a date in some time scale
    
  ** a central attraction coefficient
    
  ** an orbit defined by its keplerian parameters.
    
  []

+---------------------
// Inertial frame
Frame inertialFrame = FramesFactory.getEME2000();
// Initial date
TimeScale utc = TimeScalesFactory.getUTC();
AbsoluteDate initialDate = new AbsoluteDate(2004, 01, 01, 23, 30, 00.000,utc);
// Central attraction coefficient
double mu =  3.986004415e+14;
// Initial orbit
double a = 24396159;                // semi major axis in meters
double e = 0.72831215;              // eccentricity
double i = Math.toRadians(7);       // inclination
double omega = Math.toRadians(180); // perigee argument
double raan = Math.toRadians(261);  // right ascention of ascending node
double lM = 0;                      // mean anomaly
Orbit initialOrbit = new KeplerianOrbit(a, e, i, omega, raan, lM, PositionAngle.MEAN, 
                                        inertialFrame, initialDate, mu);
// Initial state definition
SpacecraftState initialState = new SpacecraftState(initialOrbit);
+---------------------

  Here we use a more sophisticated <NumericalPropagator> based on an some adaptive
  step integrator provided by the underlying <<<commons-math>>> library, but no matter
  which integrator is used.

+---------------------
// Adaptive step integrator
// with a minimum step of 0.001 and a maximum step of 1000
double minStep = 0.001;
double maxstep = 1000.0;
double positionTolerance = 10.0;
OrbitType propagationType = OrbitType.KEPLERIAN;
double[][] tolerances =
    NumericalPropagator.tolerances(positionTolerance, initialOrbit, propagationType);
AdaptiveStepsizeIntegrator integrator =
    new DormandPrince853Integrator(minStep, maxstep, tolerances[0], tolerances[1]);
+---------------------

  We set up the integrator, and force it to use Keplerian parameters for propagation.

+---------------------
NumericalPropagator propagator = new NumericalPropagator(integrator);
propagator.setOrbitType(propagationType);
+---------------------

  A force model, reduced here to a single perturbing gravity field, is taken into account.\
  More precisions on force models can be found
  in the {{{../architecture/forces.html}forces section}}
  of the library architecture documentation.

+---------------------
Frame ITRF2005 = FramesFactory.getITRF2005(); // terrestrial frame
double ae  =  6378137.;                       // equatorial radius in meter
double c20 = -1.08262631303e-3;               // J2 potential coefficient

// potential coefficients arrays (only J2 is considered here)
double[][] c = new double[3][1];
c[0][0] = 0.0;
c[2][0] = c20;
double[][] s = new double[3][1];
ForceModel cunningham = new CunninghamAttractionModel(ITRF2005, ae, mu, c, s);
+---------------------

  This force model is simply added to the propagator:

+---------------------
propagator.addForceModel(cunningham);
+---------------------

  The propagator operating mode is set to master mode with fixed step and a
  <TutorialStepHandler> which implements the interface <OrekitFixedStepHandler>
  in order to fulfill the <handleStep> method to be called within the loop.
  For the purpose of this tutorial, the <handleStep> method will just print
  the current state at the moment.

+---------------------
propagator.setMasterMode(60., new TutorialStepHandler());
+---------------------

  Then, the initial state is set for the propagator:

+---------------------
propagator.setInitialState(initialState);
+---------------------

  Finally, the propagator is just asked to propagate, from the initial state, for a given duration.

+---------------------
SpacecraftState finalState =
    propagator.propagate(new AbsoluteDate(initialDate, 630.));
+---------------------

  Clearly, with a few lines of code, the main application delegates to the propagator
  the care of handling regular outputs through a variable step integration loop.

  The only need is to derived some class from the interface <OrekitFixedStepHandler>
  to realize a <handleStep> method, as follows:

+---------------------
private static class TutorialStepHandler implements OrekitFixedStepHandler {

    public void handleStep(SpacecraftState currentState, boolean isLast) {
        System.out.println(" time : " + currentState.getDate());
        System.out.println(" " + currentState.getOrbit());
        if (isLast) {
            System.out.println(" this was the last step ");
        }
    }

}
+---------------------
  
  For the same result, with the slave mode, it would have required much more programming.

  The printed results are shown below:

+---------------------
 time : 2004-01-01T23:30:00.000
 keplerian parameters: {a: 2.4396159E7; e: 0.72831215; i: 7.0; pa: 180.0; raan: 261.0; v: 0.0;}
 time : 2004-01-01T23:31:00.000
 keplerian parameters: {a: 2.439564424480015E7; e: 0.7283054179012741; i: 6.999949573716115; pa: 180.01089879431635; raan: 260.9999744509341; v: 5.270522984259634;}
 time : 2004-01-01T23:32:00.000
 keplerian parameters: {a: 2.4394130981544524E7; e: 0.7282856263106472; i: 6.999800432744152; pa: 180.02168751826343; raan: 260.9997982967906; v: 10.50387496695558;}
 time : 2004-01-01T23:33:00.000
 keplerian parameters: {a: 2.4391710665289845E7; e: 0.7282539637676634; i: 6.999563066306985; pa: 180.03226220891892; raan: 260.99933874845317; v: 15.664604011799053;}
 time : 2004-01-01T23:34:00.000
 keplerian parameters: {a: 2.438852138985819E7; e: 0.7282122258929671; i: 6.9992532645274546; pa: 180.04252939476373; raan: 260.9984960696569; v: 20.720499012905563;}
 time : 2004-01-01T23:35:00.000
 keplerian parameters: {a: 2.438473009191154E7; e: 0.7281625851163973; i: 6.998890000900681; pa: 180.05240967921347; raan: 260.9972118041821; v: 25.643756282394765;}
 time : 2004-01-01T23:36:00.000
 keplerian parameters: {a: 2.4380513619406037E7; e: 0.7281073453198131; i: 6.998493179635541; pa: 180.06183982161005; raan: 260.9954699357843; v: 30.411707875362936;}
 time : 2004-01-01T23:37:00.000
 keplerian parameters: {a: 2.4376042162606522E7; e: 0.7280487266192758; i: 6.998081669198389; pa: 180.0707733525973; raan: 260.9932919569584; v: 35.00709604303499;}
 time : 2004-01-01T23:38:00.000
 keplerian parameters: {a: 2.4371467133870374E7; e: 0.727988707383731; i: 6.997671877833683; pa: 180.07917999091737; raan: 260.99072804117174; v: 39.41795154717632;}
 time : 2004-01-01T23:39:00.000
 keplerian parameters: {a: 2.4366914169719197E7; e: 0.7279289324335715; i: 6.99727695633292; pa: 180.08704419756123; raan: 260.98784670576674; v: 43.63716855903322;}
 time : 2004-01-01T23:40:00.000
 keplerian parameters: {a: 2.436248074752743E7; e: 0.7278706810843818; i: 6.996906568384245; pa: 180.09436319418123; raan: 260.9847250080804; v: 47.66188030915512;}
 this was the last step 
 Final date  : 2004-01-01T23:40:30.000
 Final state : keplerian parameters: {a: 2.4360331834936075E7; e: 0.7278424290862751; i: 6.996732681960374; pa: 180.097820317503; raan: 260.98309840201875; v: 49.6013850854552;}
+---------------------

*** Source code

  The complete code for this example can be found in the source tree of the library,
  in file <<<src/tutorials/fr/cs/examples/propagation/MasterMode.java>>>.

** Ephemeris mode

  This third mode may be used when the user needs random access to the orbit state
  at any time between some initial and final dates.

  Like in the two tutorials above, let's first define some initial state with:

  ** an inertial frame

  ** a date in some time scale
    
  ** a central attraction coefficient
    
  ** an orbit defined by its keplerian parameters.
    
  []

+---------------------
// Inertial frame
Frame inertialFrame = FramesFactory.getEME2000();
// Initial date
TimeScale utc = TimeScalesFactory.getUTC();
AbsoluteDate initialDate = new AbsoluteDate(2004, 01, 01, 23, 30, 00.000,utc);
// Central attraction coefficient
double mu =  3.986004415e+14;
// Initial orbit
double a = 24396159;                // semi major axis in meters
double e = 0.72831215;              // eccentricity
double i = Math.toRadians(7);       // inclination
double omega = Math.toRadians(180); // perigee argument
double raan = Math.toRadians(261);  // right ascention of ascending node
double lM = 0;                      // mean anomaly
Orbit initialOrbit = new KeplerianOrbit(a, e, i, omega, raan, lM, PositionAngle.MEAN, 
                                        inertialFrame, initialDate, mu);
// Initial state definition
SpacecraftState initialState = new SpacecraftState(initialOrbit);
+---------------------

  Here we use a simple <NumericalPropagator>, without perturbation,
  based on a classical fixed step Runge-Kutta integrator provided
  by the underlying <<<commons-math>>> library.

+---------------------
double stepSize = 10;
FirstOrderIntegrator integrator = new ClassicalRungeKuttaIntegrator(stepSize);
NumericalPropagator propagator = new NumericalPropagator(integrator);
+---------------------

  The initial state is set for this propagator:

+---------------------
 propagator.setInitialState(initialState);
+---------------------

  Then, the propagator operating mode is simply set to ephemeris mode:

+---------------------
propagator.setEphemerisMode();
+---------------------
            
  And the propagation is performed for a given duration.

+---------------------
SpacecraftState finalState =
    propagator.propagate(new AbsoluteDate(initialDate, 6000));
+---------------------

  This <finalState> can be used for anything, to be printed for example just like below:

+---------------------
 Numerical propagation :
  Final date : 2004-01-02T01:10:00.000
  equinoctial parameters: {a: 2.4396159E7;
                           ex: 0.11393312156755062; ey: 0.719345418868777;
                           hx: -0.009567941763699867; hy: -0.06040960680288257;
                           lv: 583.1250344407331;}
+---------------------

  Throughout the propagation, intermediate states are stored
  within an ephemeris which can be recovered now just with one instruction:
  
+---------------------
BoundedPropagator ephemeris = propagator.getGeneratedEphemeris();
System.out.println(" Ephemeris defined from " + ephemeris.getMinDate() +
                   " to " + ephemeris.getMaxDate());
+---------------------

  The ephemeris is defined as a <BoundedPropagator>, which means that it is valid
  only between the propagation initial and final dates. The code above give the
  following result:

+---------------------
 Ephemeris defined from 2004-01-01T23:30:00.000 to 2004-01-02T01:10:00.000
+---------------------

  Between these dates, the ephemeris can be used as any propagator to propagate
  the orbital state towards any intermediate date just with one instruction:
  
+---------------------
SpacecraftState intermediateState = ephemeris.propagate(intermediateDate);
+---------------------

  Here are results obtained with intermediate dates set to 3000 second after
  start date and to exactly the final date:

+---------------------
 Ephemeris propagation :
  date :  2004-01-02T00:20:00.000
  equinoctial parameters: {a: 2.4396159E7;
                           ex: 0.11393312156755062; ey: 0.719345418868777;
                           hx: -0.009567941763699867; hy: -0.06040960680288257;
                           lv: 559.0092657655284;}
  date :  2004-01-02T01:10:00.000
  equinoctial parameters: {a: 2.4396159E7;
                           ex: 0.11393312156755062; ey: 0.719345418868777;
                           hx: -0.009567941763699867; hy: -0.06040960680288257;
                           lv: 583.1250344407331;}
+---------------------

  The following shows the error message we get when we try to use a date outside
  of the ephemeris range (in this case, the intermediate date was set to 1000 seconds
  before ephemeris start:

+---------------------
out of range date for ephemerides: 2004-01-01T23:13:20.000
+---------------------

*** Source code

  The complete code for this example can be found in the source tree of the library,
  in file <<<src/tutorials/fr/cs/examples/propagation/EphemerisMode.java>>>.

* Events management

  This tutorial aims to show the power and simplicity of the event handling mechanism.
  
  One needs to check the visibility between a satellite and a ground station during some
  time range.
  
  We will use, and extend, the predefined <ElevationDetector> to perform the task.
  
  First, let's set up an initial state for the satellite defined by a position
  and a velocity at one date in some inertial frame.

+---------------------
Vector3D position  = new Vector3D(-6142438.668, 3492467.560, -25767.25680);
Vector3D velocity  = new Vector3D(505.8479685, 942.7809215, 7435.922231);
PVCoordinates pvCoordinates = new PVCoordinates(position, velocity);
AbsoluteDate initialDate =
    new AbsoluteDate(2004, 01, 01, 23, 30, 00.000, TimeScalesFactory.getUTC());
Frame inertialFrame = FramesFactory.getEME2000();
+---------------------

  We also need to set the central attraction coefficient
  to define the initial orbit as a <KeplerianOrbit>.

+---------------------
double mu =  3.986004415e+14;
Orbit initialOrbit =
    new KeplerianOrbit(pvCoordinates, inertialFrame, initialDate, mu);
+---------------------

  More precisions on the orbit representation can be found
  in the {{{../architecture/orbits.html}orbits section}}
  of the library architecture documentation.

  As a propagator, we consider a <KeplerianPropagator> to compute the simple keplerian motion.
  It could be more elaborate without modifying the general purpose of this tutorial.

+---------------------
Propagator kepler = new KeplerianPropagator(initialOrbit);
+---------------------

  Then, let's define the ground station by its coordinates as a <GeodeticPoint>:

+---------------------
double longitude = Math.toRadians(45.);
double latitude  = Math.toRadians(25.);
double altitude  = 0.;
GeodeticPoint station1 = new GeodeticPoint(latitude, longitude, altitude);
+---------------------

  And let's associate to it a <TopocentricFrame> related to a <BodyShape> in some terrestrial frame.

+---------------------
double ae =  6378137.0;                // equatorial radius in meter
double f  =  1.0 / 298.257223563;      // flattening
Frame ITRF2005 = FramesFactory.getITRF2005();  // terrestrial frame at an arbitrary date
BodyShape earth = new OneAxisEllipsoid(ae, f, ITRF2005);
TopocentricFrame sta1Frame = new TopocentricFrame(earth, station1, "station1");
+---------------------

  More precisions on <BodyShape> and <GeodeticPoint> can be found
  in the {{{../architecture/bodies.html}bodies section}}
  of the library architecture documentation.\
  More precisions on <TopocentricFrame> can be found
  in the {{{../architecture/frames.html}frames section}}
  of the library architecture documentation.

  An <EventDetector> is defined as a <VisibilityDetector> which is derived
  from an <ElevationDetector> with the same specific parameters.

+---------------------
double maxcheck  = 1.;
double elevation = Math.toRadians(5.);
EventDetector sta1Visi = new VisibilityDetector(maxcheck, elevation, sta1Frame);
+---------------------

  This <EventDetector> is added to the propagator:

+---------------------
kepler.addEventDetector(sta1Visi);
+---------------------

  Finally, the propagator is simply asked to perform until some final date,
  in slave mode by default.

  It will propagate from the initial date to the first raising or for the fixed duration
  according to the behavior implemented in the <VisibilityDetector> class.

+---------------------
SpacecraftState finalState =
    kepler.propagate(new AbsoluteDate(initialDate, 1500.));
+---------------------

  The main application code is very simple, all the work is done inside the propagator
  thanks to the <VisibilityDetector> class especially created for the purpose.

  This class extends the <ElevationDetector> class, furnished by OREKIT, by overriding the
  <eventOccurred> method with the special ability to print the results of the visibility
  check, both the raising and the setting time, and to stop the propagation just after
  the setting detection.

  The printed result is shown below.
  We can see that the propagation stopped just after detecting the raising:

+---------------------
Visibility on station1 begins at 2004-01-01T23:31:52.097
Visibility on station1 ends at 2004-01-01T23:42:48.850
Final state : 2004-01-01T23:42:48.850
+---------------------

** Source code

  The complete code for this example can be found in the source tree of the library,
  in file <<<src/tutorials/fr/cs/examples/propagation/VisibilityCheck.java>>>.
