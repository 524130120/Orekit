/* Copyright 2002-2017 CS Systèmes d'Information
 * Licensed to CS Systèmes d'Information (CS) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * CS licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.orekit.models.earth;

import org.hipparchus.geometry.euclidean.threed.Vector3D;
import org.hipparchus.util.FastMath;
import org.orekit.errors.OrekitException;
import org.orekit.frames.Frame;
import org.orekit.time.AbsoluteDate;
import org.orekit.utils.IERSConventions;
import org.orekit.utils.PVCoordinatesProvider;

/**
 * Modeling of displacement of reference points due to tidal effects.
 * <p>
 * This class implements displacement of reference point (i.e.
 * {@link org.orekit.estimation.measurements.GroundStation ground stations})
 * due to tidal effects, as per IERS conventions.
 * </p>
 * @see org.orekit.estimation.measurements.GroundStation
 * @since 9.1
 * @author Luc Maisonobe
 */
public class TidalDisplacement {

    /** Earth frame. */
    private final Frame earthFrame;

    /** Sun motion model. */
    private final PVCoordinatesProvider sun;

    /** Moon motion model. */
    private final PVCoordinatesProvider moon;

    /** Factor for degree 2 tide generated by Sun. */
    private final double ratio2S;

    /** Factor for degree 3 tide generated by Sun. */
    private final double ratio3S;

    /** Factor for degree 2 tide generated by Moon. */
    private final double ratio2M;

    /** Factor for degree 3 tide generated by Moon. */
    private final double ratio3M;

    /** Displacement Shida number h⁽⁰⁾. */
    private final double hSup0;

    /** Displacement Shida number h⁽²⁾. */
    private final double hSup2;

    /** Displacement Shida number h₃. */
    private final double h3;

    /** Displacement Love number l⁽⁰⁾. */
    private final double lSup0;

    /** Displacement Love number l⁽²⁾. */
    private final double lSup2;

    /** Displacement Love number l₃. */
    private final double l3;

    /** Simple constructor.
     * @param earthFrame Earth frame
     * @param rEarth Earth equatorial radius (from gravity field model)
     * @param sunEarthSystemMassRatio Sun/(Earth + Moon) mass ratio
     * @param earthMoonMassRatio Earth/Moon mass ratio
     * @param sun Sun model
     * @param moon Moon model
     * @param conventions IERS conventions for displacement model
     */
    public TidalDisplacement(final Frame earthFrame, final double rEarth,
                             final double sunEarthSystemMassRatio,
                             final double earthMoonMassRatio,
                             final PVCoordinatesProvider sun, final PVCoordinatesProvider moon,
                             final IERSConventions conventions) {

        final double sunEarthMassRatio = sunEarthSystemMassRatio * (1 + 1 / earthMoonMassRatio);
        final double moonEarthMassRatio = 1.0 / earthMoonMassRatio;

        this.earthFrame = earthFrame;
        this.sun        = sun;
        this.moon       = moon;

        final double r2 = rEarth * rEarth;
        final double r4 = r2 * r2;
        this.ratio2S    = r4 * sunEarthMassRatio;
        this.ratio3S    = ratio2S * rEarth;
        this.ratio2M    = r4  * moonEarthMassRatio;
        this.ratio3M    = ratio2M * rEarth;

        // Get the nominal values for the Love and Shiva numbers
        final double[] hl = conventions.getNominalTidalDisplacementLoveAndShida();
        hSup0 = hl[0];
        hSup2 = hl[1];
        h3    = hl[2];
        lSup0 = hl[3];
        lSup2 = hl[4];
        l3    = hl[5];

    }

    /** Get the Earth frame.
     * @return earth frame
     */
    public Frame getEarthFrame() {
        return earthFrame;
    }

    /** Compute displacement of a ground reference point.
     * @param date current date
     * @param referencePoint reference point position in {@link #getEarthFrame() Earth frame}
     * @return displacement vector to be <em>added</em> to {@code referencePoint}
     * @exception OrekitException if Sun or Moon position cannot be retrieved in Earth frame
     */
    public Vector3D displacement(final AbsoluteDate date, final Vector3D referencePoint)
        throws OrekitException {

        // step 1 in IERS procedure: corrections in the time domain
        final Vector3D displacement1 = timeDomainCorrection(date, referencePoint);

        // step 2 in IERS procedure: corrections in the frequency domain
        final Vector3D displacement2 = frequencyDomainCorrection(date, referencePoint);

        return displacement1.add(displacement2);

    }

    /** Compute the corrections in the time domain (step 1 in IERS procedure).
     * @param date current date
     * @param referencePoint reference point position in {@link #getEarthFrame() Earth frame}
     * @return displacement of the reference point
     * @exception OrekitException if Sun or Moon position cannot be retrieved in Earth frame
     */
    private Vector3D timeDomainCorrection(final AbsoluteDate date, final Vector3D referencePoint)
        throws OrekitException {

        // (3 sin²φ - 1) / 2 where φ is geoCENTRIC latitude of the reference point (NOT geodetic latitude)
        final double x2Py2 = referencePoint.getX() * referencePoint.getX() +
                             referencePoint.getY() * referencePoint.getY();
        final double z2    = referencePoint.getZ() * referencePoint.getZ();
        final double r2    = x2Py2 + z2;
        final double f     = (z2 - 0.5 * x2Py2) / r2;
        final double r     = FastMath.sqrt(r2);

        // geocenter to tide generating body
        final Vector3D s    = sun.getPVCoordinates(date, earthFrame).getPosition();
        final double sNorm2 = s.getNormSq();
        final double sNorm  = FastMath.sqrt(sNorm2);
        final double sNorm3 = sNorm2 * sNorm;
        final double sNorm4 = sNorm2 * sNorm2;
        final double sDot   = Vector3D.dotProduct(s, referencePoint) / (sNorm * r);
        final double sDot2  = sDot * sDot;

        final Vector3D m    = moon.getPVCoordinates(date, earthFrame).getPosition();
        final double mNorm2 = m.getNormSq();
        final double mNorm  = FastMath.sqrt(mNorm2);
        final double mNorm3 = mNorm2 * mNorm;
        final double mNorm4 = mNorm2 * mNorm2;
        final double mDot   = Vector3D.dotProduct(m, referencePoint) / (mNorm * r);
        final double mDot2  = mDot * mDot;

        // Step 1: corrections in the time domain

        final double h2 = hSup0 + hSup2 * f;
        final double l2 = lSup0 + lSup2 * f;

        // in-phase, degree 2 (equation 7.5 in IERS conventions 2010)
        final double fs2 = ratio2S / sNorm3;
        final double s2R = fs2 * 3 * l2 * sDot;
        final double s2r = fs2 * h2 * 0.5 * (3 * sDot2 - 1) - s2R * sDot;
        final double fm2 = ratio2M / mNorm3;
        final double m2R = fm2 * 3 * l2 * mDot;
        final double m2r = fm2 * h2 * 0.5 * (3 * mDot2 - 1) - m2R * mDot;

        // in-phase, degree 3 (equation 7.6 in IERS conventions 2010)
        final double fs3 = ratio3S / sNorm4;
        final double s3R = fs3 * l3 * (7.5 * sDot2 - 1.5);
        final double s3r = fs3 * h3 * sDot * (2.5 * sDot2 - 1.5) - s3R * sDot;
        final double fm3 = ratio3M / mNorm4;
        final double m3R = fm3 * l3 * (7.5 * mDot2 - 1.5);
        final double m3r = fm3 * h3 * mDot * (2.5 * mDot2 - 1.5) - m3R * mDot;

        // out-of-phase, degree 2, diurnal tides (equation 7.10 in IERS conventions 2010)
        // TODO

        // out-of-phase, degree 2, semidiurnal tides (equation 7.11 in IERS conventions 2010)
        // TODO

        // latitude dependency, diurnal tides (equation 7.8 in IERS conventions 2010)
        // TODO

        // latitude dependency, semidiurnal tides (equation 7.9 in IERS conventions 2010)
        // TODO

        // combine contributions along radial, Sun and Moon directions
        return new Vector3D((s2r + m2r + s3r + m3r) / r, referencePoint,
                            (s2R + s3R) / sNorm,         s,
                            (m2R + m3R) / mNorm,         m);

    }

    /** Compute the corrections in the frequency domain (step 2 in IERS procedure).
     * @param date current date
     * @param referencePoint reference point position in {@link #getEarthFrame() Earth frame}
     * @return displacement of the reference point
     */
    private Vector3D frequencyDomainCorrection(final AbsoluteDate date, final Vector3D referencePoint) {

        // in phase, degree 2, diurnal tides (equation 7.12 in IERS conventions 2010)
        // TODO

        // in phase and out-of-phase, degree 2, long-period tides (equation 7.13 in IERS conventions 2010)
        // TODO

        return Vector3D.ZERO;

    }

}
